# 大话数据结构-读书笔记

## 第1章 数据结构绪论

> 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。

### 一、数据的基本概念

![数据的基本概念](imgs/数据的基本概念.PNG)

#### 1、数据
> 数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。

数据不仅包括整型、浮点型等数值类型，还包括字符及声音、图像、视频等非数值类型，其中声音、图像和视频等可以通过编码的手段变成字符数据来处理。

#### 2、数据元素
> 数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。

#### 3、数据项
> 数据项是数据不可分割的最小单位，一个数据元素可以由若干个数据项组成。

#### 4、数据对象
> 数据对象是性质相同的数据元素的集合，是数据的子集。

在实际应用中，处理的数据元素通常具有相同性质，因此，一般地，数据对象可以简称为数据（在不产生的混淆的情况下）。

### 二、数据结构的基本概念

> 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

![数据结构的基本概念](imgs/数据结构的基本概念.PNG)

#### 1、逻辑结构
> 逻辑结构是指数据对象中数据元素之间的相互（逻辑）关系。

逻辑结构有四种：
1. 集合结构：数据元素除了同属一个集合外，没有其他关系。类似于数学长的集合。
2. 线性结构：数据元素之间是一对一的关系。
3. 树形结构：数据元素之间是一对多的关系。
4. 图形结构：数据元素之间是多对多的关系。

#### 2、物理结构
> 物理结构，又称存储结构，是指数据的逻辑结构在计算机中的存储形式。

物理结构的关键之处是正确反映数据元素之间的逻辑关系。

物理结构有两种：
1. 顺序存储结构：数据元素存放在地址连续的存储单元，数据间的逻辑关系和物理关系一致
2. 链式存储结构：数据元素存放在任意的存储单元，数据间的物理关系并不能反映逻辑关系

逻辑结构是面向问题的，物理结构是面向计算的，物理结构的基本目标就是将数据及其逻辑关系存储到计算机的内存中

### 三、抽象数据类型及其描述

#### 1、数据类型
> 数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称

#### 2、抽象数据类型
> 抽象数据类型（Abstract Data Type, ADT）是指一个数学模型及定义在该模型上的一组操作。

#### 3、描述抽象数据类型的标准格式
```
ADT 抽象数据类型名
Data
    数据元素之间逻辑关系的定义
Operation
    操作1
        初始条件
        操作结果描述
    操作2
        ......
    操作n
        ......
endADT
```

## 第2章 算法（绪论）

### 一、基础概念
#### 1、数据结构和算法的关系
数据结构和算法是密不可分的关系，两者相互依赖，相辅相成。

#### 2、算法的定义
> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法定义中提到的指令，是指能被人或计算机理解执行的，它可以是计算机中的指令，也可以是我们平时的语言文字。

#### 3、算法的特性
+ 输入：零个及以上个数的输入
+ 输出：一个及以上个数的输出
+ 有穷性：算法在执行有限步骤之后，自动结束（不会出现无限循环），且每一个步骤在可接受的时间内完成
+ 确定性：算法的每个步骤具有确定含义（无歧义）
+ 可行性：算法的每个步骤都是可行的

#### 4、（好）算法的设计要求
+ 正确性：至少应该具有输入、输出和加工处理无歧义性，能正确反映问题需求，能得到问题的正确答案
+ 可读性：便于阅读、理解和交流
+ 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或未知结果
+ 效率高（时间复杂度低）
+ 存储量低（空间复杂度低）

针对算法的“正确”，可分四个层次（一般情况下，将层次3作为一个算法正确性的检验标准）：
1. 算法程序没有语法错误
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果
3. 算法程序对于非法的输入数据能够产生满足规格说明的结果
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果

#### 5、算法效率的度量方法
+ 事后统计方法：缺陷较大，不予采纳
+ 事前分析估算方法

#### 6、函数的渐近增长
> 给定两个函数 $f(n)$ 和 $g(n)$，如果存在一个整数 $N$，使得对于所有的 $n>N$，$f(n)$ 总是比 $g(n)$ 大，那么我们说 $f(n)$ 的增长渐近快于 $g(n)$。

#### 7、算法时间复杂度
> **大 $O$ 记法**：$T(N)$ = $O(f(n))$

常见的时间复杂度：
![常见时间复杂度](imgs/常见时间复杂度.PNG)

一般在没有特殊说明的情况下，时间复杂度都是指最坏时间复杂度。

#### 8、算法空间复杂度
> **大 $O$ 记法**：$S(N)$ = $O(f(n))$

通常，“时间复杂度”指运行时间的需求，“空间复杂度”指空间需求，而当不用限定词地使用“复杂度”时，通常是指时间复杂度。


## 第3章 线性表

### 一、线性表的定义及抽象数据类型描述

#### 1、线性表的定义
> 线性表：零个或多个数据元素的**有限序列**。

+ 序列：数据元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后驱，其他每个元素都且仅有一个前驱和后驱。
+ 有限：线性表的元素个数是有限的。事实上，在计算机中处理的对象都是有限的，无限数列只存在于数学的概念中。

#### 2、线性表的抽象数据类型描述
```
ADT 线性表（Linear list）
Data
    线性表的数据对象包含n（n>=0，n=0时称为空表）个数据元素，每个元素的类型相同。其中，除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    构造方法：
        初始化操作，建立一个空的线性表
    isEmpty()：
        判断线性表是否为空
    clear()：
        清空线性表
    getElement(int serial)：
        返回线性表中的第serial个位置元素的值
    locateElement(T element)：
        查找与给定值element相等的元素，若查找成功，返回该元素在表中的序号，否则返回0表示失败
    insert(int serial, T element)：
        在线性表中的第serial个位置插入新元素element
    append(T element)：
        在线性表的末尾附加新元素element
    delete(int serial)：
        删除线性表中第i个位置元素，并返回删除元素的值
    getLength()：
        返回线性表中元素个数
    String show()：
        显示线性表中的元素
endADT
```

### 二、线性表的分类

![线性表的类别](imgs/线性表的类别.PNG)

#### 1、顺序表
> 顺序表，即线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

通常，顺序存储结构一般使用一维数组来实现，其优点是直接通过数组下标即可访问数组元素，而缺点就是一维数组的长度在初始化时必须指定（存在最大容量，当表中元素个数超过该最大容量时，需要手动扩容才能基础存储新元素）。

+ 通过下标访问元素：直接访问，$O(1)$
+ 获取元素下标：需要遍历整个数组（for循环），$O(n)$
+ 根据下标插入：（由于最大容量限制，需要判断是否满员以进行扩容或其他操作）需要将插入位置的元素及其后继元素全部往后移动一位（从最后一位开始移动），$O(n)$
+ 根据下标删除：（空表判断）需要将删除位置的后继元素全部往前移动一位（从第一位开始移动），$O(n)$

#### 2、单链表
> 单链表由结点链结而成，每个结点除了存储本身信息（数据域）之外，还需要存储一个指示其直接后继信息（指针域），单链表的最后一个结点的指针域为NULL。

链表由结点链结而成，相对一维数组而言，其优点就是不需要担心表的容量（不存在最大容量），缺点就是相同的结点数有更多的存储空间。

+ 通过位置序号访问元素：遍历链表（while循环），$O(n)$
+ 获取元素位置序号：遍历链表，$O(n)$
+ 根据位置序号插入：在“获取元素位置序号”的基础上，插入元素[$O(1)$]
+ 根据位置序号删除：在“获取元素位置序号”的基础上，删除元素[$O(1)$]

链表问题的关键：
1. 遍历条件和遍历前的初始化
2. 头结点是否存在，如果还有尾结点，还需要考虑尾结点的变更
3. 插入元素时的顺序：`newNode.next = pre.next; pre.next = newNode;`

关键代码：
```Java
public class SinglyLinkedList<T> {
    /**
     * 头结点
     */
    protected Node<T> head;

    // /**
    //  * 链表长度
    //  */
    // protected int length;

    // 演示遍历获取链表长度，实际代码可以定义一个成员变量来保存链表长度
    public int getLengthWithTraverseNextNode(){
        Node<T> p = head;
        int count = 0;
        // p 一直指向下一个结点
        while(p != null){
            count++;
            p = p.getNext();
        }
        // 遍历结束时，p 为 null，指向最后一个结点的下一个结点
        return count;
    }

    public int getLengthWithTraverseCurrentNode(){
        if(head == null){
            return 0;
        }
        Node<T> p = head;
        int count = 1;
        // p 一直指向当前结点
        while(p.getNext() != null){
            count++;
            p = p.getNext();
        }
        // 遍历结束时，p 指向最后一个结点
        return count;
    }
}
```
#### 3、其它链表
以下链表暂未研究：
+ 静态链表
+ 循环链表
+ 双向链表

## 第4章 栈与队列

### 一、栈的定义和抽象数据类型描述

#### 1、栈的定义
> 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

栈是后进先出（Last In First Out，LIFO）的线性表。

+ 允许插入和删除的一端称为**栈顶**
+ 插入操作，称为**进栈**
+ 删除操作，称为**出栈**

#### 2、栈的抽象数据类型描述
```
ADT 栈（Stack）
Data
    栈的数据对象包含n（n>=0，n=0时称为空表）个数据元素，每个元素的类型相同。其中，除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    构造方法：
        初始化操作，建立一个空栈
    isEmpty()：
        判断栈是否为空
    clear()：
        清空栈
    getTop()：
        返回栈顶元素
    push(T element)：
        进栈，栈顶进栈
    pop()：
        出栈，栈顶出栈
    getLength()：
        返回栈中元素个数
    String show()：
        显示栈中的元素
endADT
```

### 二、栈的类型

#### 1、顺序栈
> 顺序栈，即一维数组实现栈的顺序存储结构

栈顶设置在一维数组的末尾，便于操作（如果栈顶设置在一维数组的开始，插入或删除时都需要移动元素）。

缺点仍然是一维数组的长度限制。

+ 访问栈顶：直接通过下标（最后一位）获取，$O(1)$
+ 进栈：直接在下标（一维数组末尾的后一位）赋值，$O(1)$
+ 出栈：直接将栈顶元素置空，$O(1)$

*扩展：共享栈（两个相同类型的栈共享同一个一维数组）* 

#### 2、链栈
> 链栈，即栈的链式存储结构

栈顶设置在链表的头部，即头结点

+ 访问栈顶：直接获取栈顶，$O(1)$
+ 进栈：直接将旧栈顶元素作为新元素的 `next`，并将新元素作为栈顶元素，$O(1)$
+ 出栈：直接将旧栈顶元素的 `next` 作为新的栈顶元素，$O(1)$

### 三、队列的定义和抽象数据类型描述

#### 1、队列的定义
> 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是先进先出（First In First Out，FIFO）的线性表。

+ 允许插入的一端称为**队尾**
+ 允许删除的一端称为**队头**
+ 插入操作，称为**入队**
+ 删除操作，称为**出队**

#### 2、队列的抽象数据类型描述
```
ADT 队列（Queue）
Data
    队列的数据对象包含n（n>=0，n=0时称为空表）个数据元素，每个元素的类型相同。其中，除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    构造方法：
        初始化操作，建立一个空队列
    isEmpty()：
        判断队列是否为空
    clear()：
        清空队列
    enQueue(T element)：
        入队
    deQueue()：
        出队
    getLength()：
        返回队列中元素个数
    String show()：
        显示队列中的元素
endADT
```

### 四、队列的类型

#### 1、循环队列
> 循环队列是顺序队列（即一维数组实现队列的顺序存储结构）的一种，是一种头尾相接的顺序存储结构。

由于队列的入队和出队操作在两端分别进行，在通过一维数组实现队列时，如果将下标为0的位置默认为队列的队头（队尾），删除（插入）元素时则需要移动元素。为避免移动元素，队头和队尾的位置将随着插入或删除操作也在发生变化。当队尾或队头位置移动到数组末尾时，需要再移动时，则移动到数组的开始位置。此时，该队列就是一种头尾相接的结构。

概念：
+ 队头：`front`
+ 队尾的下一个位置：`rear`
+ 队列初始状态：`rear = front = 0`
+ 队空：`rear == front`
+ 队满(数组保留一个空闲单元)：`(rear + 1)%capacity == front`
+ 队列长度：`(rear - front + capacity)%capacity`

操作：
+ 入队：直接在队尾赋值，并移动 `rear`，$O(1)$
+ 出队：直接将队头元素置空，并移动 `front`，$O(1)$


#### 2、链队列
> 链队列，即队列的链式存储结构

概念：
+ 队头：`front`，指向头结点
+ 队尾：`rear`，指向尾结点

操作：
+ 入队：直接将新元素作为队尾元素的 `next`，并将新元素作为队尾元素，$O(1)$
+ 出队：直接将旧队头元素的 `next` 作为新的队头元素，$O(1)$


### 五、我对栈和队列的一些理解

+ 栈和队列的数据结构都比较简单，也容易实现，遇上实际问题，其关键在于**出栈和入栈（入队和出队）的条件**