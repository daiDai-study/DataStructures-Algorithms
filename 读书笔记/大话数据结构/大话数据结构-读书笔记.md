# 大话数据结构-读书笔记

## 第1章 数据结构绪论

> 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。

### 一、数据的基本概念

![数据的基本概念](imgs/数据的基本概念.png)

#### 1、数据
> 数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。

数据不仅包括整型、浮点型等数值类型，还包括字符及声音、图像、视频等非数值类型，其中声音、图像和视频等可以通过编码的手段变成字符数据来处理。

#### 2、数据元素
> 数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。

#### 3、数据项
> 数据项是数据不可分割的最小单位，一个数据元素可以由若干个数据项组成。

#### 4、数据对象
> 数据对象是性质相同的数据元素的集合，是数据的子集。

在实际应用中，处理的数据元素通常具有相同性质，因此，一般地，数据对象可以简称为数据（在不产生的混淆的情况下）。

### 二、数据结构的基本概念

> 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

![数据结构的基本概念](imgs/数据结构的基本概念.png)

#### 1、逻辑结构
> 逻辑结构是指数据对象中数据元素之间的相互（逻辑）关系。

逻辑结构有四种：
1. 集合结构：数据元素除了同属一个集合外，没有其他关系。类似于数学长的集合。
2. 线性结构：数据元素之间是一对一的关系。
3. 树形结构：数据元素之间是一对多的关系。
4. 图形结构：数据元素之间是多对多的关系。

#### 2、物理结构
> 物理结构，又称存储结构，是指数据的逻辑结构在计算机中的存储形式。

物理结构的关键之处是正确反映数据元素之间的逻辑关系。

物理结构有两种：
1. 顺序存储结构：数据元素存放在地址连续的存储单元，数据间的逻辑关系和物理关系一致
2. 链式存储结构：数据元素存放在任意的存储单元，数据间的物理关系并不能反映逻辑关系

逻辑结构是面向问题的，物理结构是面向计算的，物理结构的基本目标就是将数据及其逻辑关系存储到计算机的内存中

### 三、抽象数据类型及其描述

#### 1、数据类型
> 数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称

#### 2、抽象数据类型
> 抽象数据类型（Abstract Data Type, ADT）是指一个数学模型及定义在该模型上的一组操作。

#### 3、描述抽象数据类型的标准格式
```
ADT 抽象数据类型名
Data
    数据元素之间逻辑关系的定义
Operation
    操作1
        初始条件
        操作结果描述
    操作2
        ......
    操作n
        ......
endADT
```

## 第2章 算法（绪论）

### 一、基础概念
#### 1、数据结构和算法的关系
数据结构和算法是密不可分的关系，两者相互依赖，相辅相成。

#### 2、算法的定义
> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法定义中提到的指令，是指能被人或计算机理解执行的，它可以是计算机中的指令，也可以是我们平时的语言文字。

#### 3、算法的特性
+ 输入：零个及以上个数的输入
+ 输出：一个及以上个数的输出
+ 有穷性：算法在执行有限步骤之后，自动结束（不会出现无限循环），且每一个步骤在可接受的时间内完成
+ 确定性：算法的每个步骤具有确定含义（无歧义）
+ 可行性：算法的每个步骤都是可行的

#### 4、（好）算法的设计要求
+ 正确性：至少应该具有输入、输出和加工处理无歧义性，能正确反映问题需求，能得到问题的正确答案
+ 可读性：便于阅读、理解和交流
+ 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或未知结果
+ 效率高（时间复杂度低）
+ 存储量低（空间复杂度低）

针对算法的“正确”，可分四个层次（一般情况下，将层次3作为一个算法正确性的检验标准）：
1. 算法程序没有语法错误
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果
3. 算法程序对于非法的输入数据能够产生满足规格说明的结果
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果

#### 5、算法效率的度量方法
+ 事后统计方法：缺陷较大，不予采纳
+ 事前分析估算方法

#### 6、函数的渐近增长
> 给定两个函数 $f(n)$ 和 $g(n)$，如果存在一个整数 $N$，使得对于所有的 $n>N$，$f(n)$ 总是比 $g(n)$ 大，那么我们说 $f(n)$ 的增长渐近快于 $g(n)$。

#### 7、算法时间复杂度
> **大 $O$ 记法**：$T(N)$ = $O(f(n))$

常见的时间复杂度：
![常见时间复杂度](imgs/常见时间复杂度.png)

一般在没有特殊说明的情况下，时间复杂度都是指最坏时间复杂度。

#### 8、算法空间复杂度
> **大 $O$ 记法**：$S(N)$ = $O(f(n))$

通常，“时间复杂度”指运行时间的需求，“空间复杂度”指空间需求，而当不用限定词地使用“复杂度”时，通常是指时间复杂度。


## 第3章 线性表

### 一、线性表的定义及抽象数据类型描述

#### 1、线性表的定义
> 线性表：零个或多个数据元素的**有限序列**。

+ 序列：数据元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后驱，其他每个元素都且仅有一个前驱和后驱。
+ 有限：线性表的元素个数是有限的。事实上，在计算机中处理的对象都是有限的，无限数列只存在于数学的概念中。

#### 2、线性表的抽象数据类型描述
```
ADT 线性表（Linear list）
Data
    线性表的数据对象包含n（n>=0，n=0时称为空表）个数据元素，每个元素的类型相同。其中，除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    构造方法：
        初始化操作，建立一个空的线性表
    isEmpty()：
        判断线性表是否为空
    clear()：
        清空线性表
    getElement(int serial)：
        返回线性表中的第serial个位置元素的值
    locateElement(T element)：
        查找与给定值element相等的元素，若查找成功，返回该元素在表中的序号，否则返回0表示失败
    insert(int serial, T element)：
        在线性表中的第serial个位置插入新元素element
    append(T element)：
        在线性表的末尾附加新元素element
    delete(int serial)：
        删除线性表中第i个位置元素，并返回删除元素的值
    getLength()：
        返回线性表中元素个数
    String show()：
        显示线性表中的元素
endADT
```

### 二、线性表的分类

![线性表的类别](imgs/线性表的类别.png)

#### 1、顺序表
> 顺序表，即线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

通常，顺序存储结构一般使用一维数组来实现，其优点是直接通过数组下标即可访问数组元素，而缺点就是一维数组的长度在初始化时必须指定（存在最大容量，当表中元素个数超过该最大容量时，需要手动扩容才能基础存储新元素）。

+ 通过下标访问元素：直接访问，$O(1)$
+ 获取元素下标：需要遍历整个数组（for循环），$O(n)$
+ 根据下标插入：（由于最大容量限制，需要判断是否满员以进行扩容或其他操作）需要将插入位置的元素及其后继元素全部往后移动一位（从最后一位开始移动），$O(n)$
+ 根据下标删除：（空表判断）需要将删除位置的后继元素全部往前移动一位（从第一位开始移动），$O(n)$

#### 2、单链表
> 单链表由结点链结而成，每个结点除了存储本身信息（数据域）之外，还需要存储一个指示其直接后继信息（指针域），单链表的最后一个结点的指针域为NULL。

链表由结点链结而成，相对一维数组而言，其优点就是不需要担心表的容量（不存在最大容量），缺点就是相同的结点数有更多的存储空间。

+ 通过位置序号访问元素：遍历链表（while循环），$O(n)$
+ 获取元素位置序号：遍历链表，$O(n)$
+ 根据位置序号插入：在“获取元素位置序号”的基础上，插入元素[$O(1)$]
+ 根据位置序号删除：在“获取元素位置序号”的基础上，删除元素[$O(1)$]

链表问题的关键：
1. 遍历条件和遍历前的初始化
2. 头结点是否存在，如果还有尾结点，还需要考虑尾结点的变更
3. 插入元素时的顺序：`newNode.next = pre.next; pre.next = newNode;`

关键代码：
```Java
public class SinglyLinkedList<T> {
    /**
     * 头结点
     */
    protected Node<T> head;

    // /**
    //  * 链表长度
    //  */
    // protected int length;

    // 演示遍历获取链表长度，实际代码可以定义一个成员变量来保存链表长度
    public int getLengthWithTraverseNextNode(){
        Node<T> p = head;
        int count = 0;
        // p 一直指向下一个结点
        while(p != null){
            count++;
            p = p.getNext();
        }
        // 遍历结束时，p 为 null，指向最后一个结点的下一个结点
        return count;
    }

    public int getLengthWithTraverseCurrentNode(){
        if(head == null){
            return 0;
        }
        Node<T> p = head;
        int count = 1;
        // p 一直指向当前结点
        while(p.getNext() != null){
            count++;
            p = p.getNext();
        }
        // 遍历结束时，p 指向最后一个结点
        return count;
    }
}
```
#### 3、其它链表
以下链表暂未研究：
+ 静态链表
+ 循环链表
+ 双向链表

## 第4章 栈与队列

### 一、栈的定义和抽象数据类型描述

#### 1、栈的定义
> 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

栈是后进先出（Last In First Out，LIFO）的线性表。

+ 允许插入和删除的一端称为**栈顶**
+ 插入操作，称为**进栈**
+ 删除操作，称为**出栈**

#### 2、栈的抽象数据类型描述
```
ADT 栈（Stack）
Data
    栈的数据对象包含n（n>=0，n=0时称为空表）个数据元素，每个元素的类型相同。其中，除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    构造方法：
        初始化操作，建立一个空栈
    isEmpty()：
        判断栈是否为空
    clear()：
        清空栈
    getTop()：
        返回栈顶元素
    push(T element)：
        进栈，栈顶进栈
    pop()：
        出栈，栈顶出栈
    getLength()：
        返回栈中元素个数
    String show()：
        显示栈中的元素
endADT
```

### 二、栈的类型

#### 1、顺序栈
> 顺序栈，即一维数组实现栈的顺序存储结构

栈顶设置在一维数组的末尾，便于操作（如果栈顶设置在一维数组的开始，插入或删除时都需要移动元素）。

缺点仍然是一维数组的长度限制。

+ 访问栈顶：直接通过下标（最后一位）获取，$O(1)$
+ 进栈：直接在下标（一维数组末尾的后一位）赋值，$O(1)$
+ 出栈：直接将栈顶元素置空，$O(1)$

*扩展：共享栈（两个相同类型的栈共享同一个一维数组）* 

#### 2、链栈
> 链栈，即栈的链式存储结构

栈顶设置在链表的头部，即头结点

+ 访问栈顶：直接获取栈顶，$O(1)$
+ 进栈：直接将旧栈顶元素作为新元素的 `next`，并将新元素作为栈顶元素，$O(1)$
+ 出栈：直接将旧栈顶元素的 `next` 作为新的栈顶元素，$O(1)$

### 三、队列的定义和抽象数据类型描述

#### 1、队列的定义
> 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是先进先出（First In First Out，FIFO）的线性表。

+ 允许插入的一端称为**队尾**
+ 允许删除的一端称为**队头**
+ 插入操作，称为**入队**
+ 删除操作，称为**出队**

#### 2、队列的抽象数据类型描述
```
ADT 队列（Queue）
Data
    队列的数据对象包含n（n>=0，n=0时称为空表）个数据元素，每个元素的类型相同。其中，除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    构造方法：
        初始化操作，建立一个空队列
    isEmpty()：
        判断队列是否为空
    clear()：
        清空队列
    enQueue(T element)：
        入队
    deQueue()：
        出队
    getLength()：
        返回队列中元素个数
    String show()：
        显示队列中的元素
endADT
```

### 四、队列的类型

#### 1、循环队列
> 循环队列是顺序队列（即一维数组实现队列的顺序存储结构）的一种，是一种头尾相接的顺序存储结构。

由于队列的入队和出队操作在两端分别进行，在通过一维数组实现队列时，如果将下标为0的位置默认为队列的队头（队尾），删除（插入）元素时则需要移动元素。为避免移动元素，队头和队尾的位置将随着插入或删除操作也在发生变化。当队尾或队头位置移动到数组末尾时，需要再移动时，则移动到数组的开始位置。此时，该队列就是一种头尾相接的结构。

概念：
+ 队头：`front`
+ 队尾的下一个位置：`rear`
+ 队列初始状态：`rear = front = 0`
+ 队空：`rear == front`
+ 队满(数组保留一个空闲单元)：`(rear + 1)%capacity == front`
+ 队列长度：`(rear - front + capacity)%capacity`

操作：
+ 入队：直接在队尾赋值，并移动 `rear`，$O(1)$
+ 出队：直接将队头元素置空，并移动 `front`，$O(1)$


#### 2、链队列
> 链队列，即队列的链式存储结构

概念：
+ 队头：`front`，指向头结点
+ 队尾：`rear`，指向尾结点

操作：
+ 入队：直接将新元素作为队尾元素的 `next`，并将新元素作为队尾元素，$O(1)$
+ 出队：直接将旧队头元素的 `next` 作为新的队头元素，$O(1)$


### 五、我对栈和队列的一些理解

+ 栈和队列的数据结构都比较简单，也容易实现，遇上实际问题，其关键在于**出栈和入栈（入队和出队）的条件**

## 第5章 串

### 一、串的定义和存储结构

#### 1、串的定义
> 串（string）是由零个或多个字符组成的有限序列，又名字符串。

`Java` 中，字符串是用双引号括起来的字符序列，字符是用单引号括起来的单个字符。

#### 2、串的存储结构
+ 串的存储结构与线性表相似，只是串中的每个数据元素是单个字符。
+ 总的来说，串的链式存储结构不如顺序存储结构灵活，性能也不如顺序存储结构好。

### 二、我对字符串的一些理解

+ 字符串的存储结构使用顺序存储结构（数组）更为便捷，在 `Java` 中，普通字符串（`String` 类）具有不变性，而可变的字符串（`StringBuilder` 和 `StringBuffer` 类）主要依赖两点：
    1. 数组长度的主动变化
    2. 数组数据的主动复制

## 第6章 树

### 一、树的定义和基础概念

#### 1、树的定义
> 树（Tree）是 n（n>=0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根的结点；（2）当 n>1 时，其余结点可分为 m（m>0）个互不相交的有限集，其中每一个集合本身又是一棵树，并且成为根的子树（SubTree）。

#### 2、结点的相关概念

+ 结点的度（Degree）：结点拥有的子树数
+ 叶结点（Leaf）：度为 0 的结点，又称终端结点
+ 分支结点：度不为 0 的结点，又称非终端结点，除根结点之外，分支结点也称为内部结点
+ 树的度：树内各结点的度的最大值
+ 结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）
+ 同一个双亲的孩子之间互称兄弟（Sibling）
+ 结点的祖先是从根到该结点所经分支上的所有结点，相应地，已某结点为根的子树中的任一结点都称为该结点的子孙


#### 3、树的相关概念
+ 结点的层次：结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层
+ 树的深度（Depth）或高度：树中结点的最大层次
+ 如果将树中结点的各子树看成从左至右是有次序的，不能呼唤的，则称该树为有序树，否则称为无序树
+ 森林：m（m>=0）棵互不相交的树的集合（对树中每个结点而言，其子树的集合即为森林）

### 二、树的抽象数据类型
```
ADT 树（Tree）
Data
    树是由一个根结点和若个棵子树构成。树中结点具有相同数据类型及层次关系。
Operation
    构造方法：
        初始化操作，建立一个空树
    isEmpty()：
        判断树是否为空
    clear()：
        清空树
    getDepth():
        返回树的深度
    getRoot():
        返回树的根结点
    getValue(Node n):
        若 n 是树中的一个结点，则返回该结点的值
    setValue(Node n, T val):
        给树中结点 n 赋值
    getParent(Node n):
        若 n 是树的非根结点，则返回它的双亲，否则返回空
    getLeftChild(Node n):
        若 n 是树的非叶结点，则返回的它的最左孩子，否则返回空
    getRightSibling(Node n):
        若 n 有右兄弟，则返回它的右兄弟，否则返回空
    String show()：
        显示队列中的元素
endADT
```

### 三、树的表示方法

#### 1、双亲表示法
+ 存储方式：顺序存储方式
+ 结点：包含一个数据域和一个指针域，数据域存储数据，指针域存储双亲结点的下标，默认根结点的指针域存储`-1`

+ 查找结点的双亲结点：`O(1)`
+ 查找结点的孩子结点：遍历所有结点

**扩展**：指针域可以包含多个，除了一个指向双亲结点，其他的可以是指向结点的最左孩子结点（或第一个孩子结点，如果不存在存储`-1`）或指向结点的右兄弟结点（如果不存在存储`-1`）

#### 2、孩子表示法

1. 孩子结点的指针域个数按树的度（最大）分配 --> **二叉树常用存储结构**
    + 存储方式：链表存储方式
    + 结点：包含一个数据域和多个指针域，数据域存储数据，多个指针域（个数是树的度）存储结点的孩子结点，如果孩子结点不存在则存储`NULL`

    对于树中各结点度相差较大时，空间浪费严重。

2. 孩子结点的指针域个数按需分配
    + 存储方式：链表存储方式
    + 结点：包含一个数据域、一个度域和多个指针域，数据域存储数据，度域存储结点的度，多个指针域（个数是结点的度）存储结点的孩子结点

    虽然克服了空间浪费的缺点，但每个结点的结构不同，并且需要维护度域，在运算上就会带来时间上的损耗


3. 每个结点（又称表头结点）的孩子结点排列起来组成一个单链表（孩子链表），n个结点就有n个孩子链表，如果是叶子结点则其孩子链表为空；每个结点又组成一个顺序表，存放在一个一维数组中。 --> **HashMap**
    + 存储方式：顺序存储 + 链表存储
    + 表头结点：一个数据域和一个指针域，数据域存储数据，指针域指向该结点的孩子链表，如果不存在则为空
    + 孩子链表中的孩子结点（表头结点的孩子结点）：一个下标域和一个指针域，下标域存储孩子结点的下表，指针域指向表头结点的下一个孩子节点，如果不存在则为空

    第3种方式称为孩子表示法，此方法容易找到结点的孩子结点、兄弟结点，也方便遍历，但很难找到双亲结点

4. 扩展：将孩子表示法结合双亲表示法，即可克服孩子表示法的缺点，称之为*双亲孩子表示法* --> 表头结点多一个域存储双亲结点的下标

#### 3、孩子兄弟表示法

任何一棵树，它的结点的第一个孩子如果存在就是唯一的，它的结点的右兄弟如果存在就是唯一的。--> **任何一棵树都可变成一棵二叉树**
+ 存储方式：链表存储
+ 结点：一个数据域和两个指针域，数据域存储数据，第一个指针域存储结点的第一个孩子结点，第二个指针域存储结点的右兄弟结点，如果不存在则为空

### 四、二叉树的定义及相关概念

#### 1、二叉树的定义
> 二叉树（Binary Tree）是 `n（n>=0）`个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两个互不相交的、分别称为根节点的左子树和右子树的二叉树组成。

#### 2、二叉树的特点
+ 每个结点最多有两棵子树 ==> 二叉树的度 <= 2
+ 结点的左子树和右子树是有顺序的，次序不能任意颠倒
+ 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树

#### 3、二叉树的五种形态
1. 空二叉树
2. 有根节点，无子树
3. 有根节点，只有左子树
4. 有根节点，只有右子树
5. 有根节点，既有左子树又有右子树

#### 4、特殊二叉树
1. 斜树：所有结点都只有左（或右）子树，称之为左（或右）斜树，统称为斜树
2. 满二叉树：所有分支结点都存在左子树和右子树，且所有叶结点都在同一层上
3. 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为 `i(1<=i<=n)` 的结点与同样深度的满二叉树中编号为 `i` 的结点在二叉树中位置完全相同

#### 5、二叉树的性质
1. 二叉树的第 i 层上至多有 2 sup (i-1) 个结点
2. 深度为 k 的二叉树至多有 2 sup (k) - 1 个结点
3. 对任意一棵二叉树，如果其叶结点数为n0，度为2的结点数为n2，则 `n2=n0+1`（从线的角度看有 `n0+n1+n2-1=n1+2n2`）
4. 具有 n 个结点的完全二叉树的深度为 log2n 的下界整数加1
5. 具有 n 个结点的完全二叉树按层序编号，对任一结点 `i(1<=i<=n)` 有：
    + i=1，结点为根节点
    + i>1，则其双亲是 `i/2` 的下界整数
    + 如果 `2i>n` ，则结点i无左孩子（即为叶子结点）；否则其左孩子是结点 `2i`
    + 如果 `2i+1>n`，则结点i无右孩子；否则其右孩子是结点 `2i+1`

### 五、二叉树的存储结构

#### 1、二叉树的顺序存储结构

当二叉树是一棵完全二叉树时，将该二叉树依层序存入数组（根结点存储到下标为1的位置，更为方便）中，此时用顺序结构非常便捷；当二叉树是一棵非完全二叉树时，也可以将其按完全二叉树编号存放，但需要将不存在的结点设置为 `Null`，如果二叉树是一棵深度为 `k` 的右斜树，它只有 `k` 个结点，此时需要分配 `2^k - 1` 个存储单元空间，显然存储空间存在极大的浪费。

> 顺序存储结构一般只用于完全二叉树。

#### 2、二叉树的链表存储结构 --> 二叉链表

每个结点包含一个数据域和两个指针域，两个指针域分别指向该节点的左孩子和右孩子

**存储空间推算：**`k` 个结点，需要分配 `3k` 个存储单元空间，其中有效存储单元空间为 `2*k-1` 个（`k` 个结点和 `k-1` 条线），无效存储单元空间为 `k+1` 个

### 六、二叉树的遍历

> 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。

#### 1、层序遍历

> 若二叉树为空，则空操作返回，否则从二叉树的第一层（根结点）开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

#### 2、前序遍历

> 若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。

#### 3、中序遍历

> 若二叉树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。

#### 4、后序遍历

> 若二叉树为空，则空操作返回，否则从根结点开始，后序遍历根结点的左子树，然后后序遍历右子树，最后访问根结点。

#### 5、遍历总结

1. 层序遍历适用于顺序存储结构
2. 前序、中序、后序遍历适用于链表存储结构（二叉链表）
3. 已知前序遍历（或后序遍历）序列和中序遍历序列，可以唯一确定一棵二叉树；已知前序遍历序列和后序遍历序列，不能唯一确定一棵二叉树
4. 通过遍历的方式也可以去建立一棵二叉树，不同之处就是将**访问结点的操作**改为**生成结点并赋值的操作**

### 七、线索二叉树（线索二叉链表）

> 利用起空指针，存放指向结点在某种遍历次序下的前驱和后继结点的地址，此时的二叉树成为线索二叉树（Threaded Binary Tree）。

线索二叉树中为了区分指针域指向的是左孩子还是前驱（或是右孩子还是后继），需要增设两个标志域进行标识。


### 八、树、森林和二叉树的转换

#### 1、树和二叉树的转换

> 树采用孩子兄弟表示法即可转换成二叉树

#### 2、森林和二叉树的转换

> 森林中的每一棵树都是兄弟

森林转换为二叉树的步骤：
1. 将每棵树转换为二叉树；
2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子

### 九、赫夫曼树及其应用

> 文本压缩 --> 将要压缩的文本重新编码 --> 最基本的压缩编码方法（赫夫曼编码） --> 赫夫曼树

#### 1、基础概念

1. 路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度
2. 树的路径长度：从树根到每个结点的路径长度之和
3. 结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积
4. 树的带权路径长度：树中所有叶子结点的带权路径长度之和

#### 2、赫夫曼树的定义

> 一棵有 n 个叶子结点的二叉树，每个叶子结点带全 wk，每个叶子的路径长度 lk，其中带权路径长度（WPL）最小的二叉树称为赫夫曼树，又称最优二叉树。

#### 3、赫夫曼树的构造

1. 先将有权值的叶子结点按照权值从小打到的顺序排列成一个有序序列
2. 取头两个最小权值的节点作为一个新结点的两个子结点，注意相对较小的是左孩子，新结点的权值为两个子结点的权值之和；从有序序列中删除两个子节点，并将新结点插入到有序序列中
3. 重复步骤2，直到只有一个结点，且该结点为赫夫曼树的根结点

#### 4、赫夫曼编码及其应用

> 赫夫曼编码的原理：将文本中每个字符出现的频率作为该字符的权值，根据字符及其权值构造一棵赫夫曼树，将赫夫曼树中每个权值左分支改为 0，右分支改为 1，之后每个字符用其从树根到叶子所经过的路径的 0 或 1 来编码。

通过赫夫曼编码技术可以将文本进行压缩